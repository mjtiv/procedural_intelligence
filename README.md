# Procedural Intelligence

> AI models are becoming like cell phone providers.  
> Different plans, different quirks, but all basically giving you access to the same signal.

**Procedural Intelligence** offers something different.

It introduces a **model-agnostic layer of control**—where users define the rules, memory limits, and behavioral boundaries of artificial agents, regardless of provider.  
At its core is a new file type: `.aix` — a flat, structured capsule that encapsulates *what* an intelligent task is, *how* it should behave, and *what scope and identity* it must obey.

---

## 🔁 What It Does

Procedural Intelligence abstracts over LLM infrastructure, allowing AI workflows to be:

- **Spun up or shut down across different models** without behavioral drift
- **Scoped to a role or domain**, enforcing memory TTL and identity tagging
- **Logged and reversible**, making decisions traceable via audit trails
- **Composable and portable**, enabling versioned procedures shared across teams

This isn't about building the next foundation model.  
It's about **standardizing how AI behaves**—so intelligence can be reused, not just re-prompted.

---

## 🧠 What Is Procedural Intelligence?

Where:
- Traditional AI focuses on prediction and behavior
- Machine Learning focuses on patterns and statistics

**Procedural Intelligence focuses on structure, scope, and memory**.

It defines *how* reasoning happens:
- What identity an agent holds
- What memory it can access
- What zone it’s allowed to operate in
- How long it can persist before reset
- Whether it can communicate with other agents—and under what trust rules

It brings AI back into human-governed systems: versioned, auditable, reproducible.

---

## 🧱 Foundations

- `.aix` is the flat file foundation of Procedural Intelligence.  
  It governs execution rules: PID, TTL, Zones, Audit Trails, and Trust Scopes.

- Tools like **CryptoTone** show `.aix` in action.  
  CryptoTone runs scoped tone-profiling workflows inside ChatGPT using `.aix` capsules—demonstrating identity enforcement, memory control, and scoped reasoning without external code.

- PI is **provider-agnostic**:  
  It works across OpenAI, Anthropic, Mistral, etc., so long as a model can interpret structured prompts and store execution state.

---

## 🧭 What's Next (Depending on if this takes off like a rocket ship and I have cash)

We’re beginning to define the components of this emerging architecture.

Planned areas of development include:

- **PI Runners** – Lightweight interpreters that read `.aix` files and simulate scoped AI execution
- **PI Memory Wrappers** – Tools for limiting memory drift and enforcing TTL in prompt chains
- **Capsule Libraries** – Reusable `.aix` capsules for science, law, education, and analysis
- **Audit Trails** – Simple mechanisms for tracking decision history, rollback events, and zone violations

These are exploratory directions, not finished products.

As the framework evolves, we'll release demos and tooling under open licenses.  
We're moving fast—but deliberately.

---

## 🌍 Why This Matters

AI infrastructure is centralizing fast.  
Prompt engineering won't scale.  
Model access is becoming siloed, usage-locked, and memoryless.

**Procedural Intelligence** flips the power dynamic:

- Users regain control of AI behavior.
- Workflows become assets—not one-off prompts.
- Small teams can build *modular agent networks* that scale across providers.

This is the **cottage industry of AI**—where users own the process, not just the output.

Procedural Intelligence is not a company.  
It’s not a product.  
It’s a discipline.  
And it's just beginning.

---

> We don’t just build agents.  
> We build procedures for intelligence.
